From 414222d203c118e889292285dd002d17fd4348d1 Mon Sep 17 00:00:00 2001
From: Maulik Patel <maulik.patel@arm.com>
Date: Mon, 13 Oct 2025 15:53:34 +0100
Subject: [PATCH] BL2: Backport some changes from mcuboot PR#2305
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This patch backports updates from MCUboot PR#2305 that were missed in the
existing TF-M integration patches.

Key changes:
- Renamed `bootutil_image_hash.c` â†’ `bootutil_img_hash.c` for consistency
  with MCUboot.
- Added new source `bootutil_img_security_cnt.c` to bootutil CMake list.
- Removed outdated hardware rollback protection handling from
  `bootutil/CMakeLists.txt` as mcuboot config are handled via header.
- Cleaned up unused definitions in `bootutil/include/bootutil/image.h`.
- Extended `bootutil/include/bootutil/sign_key.h` to include additional
  key types and helper macros.
- Minor corrections in `bootutil_find_key.c` and image validation paths.
- Synced image hashing and validation function naming with MCUboot.
- Added release note: `multi-signature-support.md`.
- Updated `mcuboot_config.template.h` with new signature configuration
  macros.
- Improved Python `imgtool/image.py` to support multi-signature options.
- Minor Rust build update in `sim/mcuboot-sys/build.rs`.

For further details, please refer to comments on the mcuboot PR.

Signed-off-by: Maulik Patel <maulik.patel@arm.com>
Change-Id: Iacbed759a75fff39236e21a41bb8fa860a0c205f
---
 boot/bootutil/CMakeLists.txt                  | 16 ++---------
 boot/bootutil/include/bootutil/image.h        |  6 -----
 boot/bootutil/include/bootutil/sign_key.h     | 25 ++++++++++++++++-
 boot/bootutil/src/bootutil_find_key.c         |  9 +++----
 ...tutil_image_hash.c => bootutil_img_hash.c} |  7 +++--
 boot/bootutil/src/image_ed25519.c             |  2 +-
 boot/bootutil/src/image_validate.c            |  5 ++--
 boot/espressif/CMakeLists.txt                 |  3 +++
 boot/zephyr/CMakeLists.txt                    |  3 +++
 .../multi-signature-support.md                |  2 ++
 .../mcuboot_config/mcuboot_config.template.h  | 16 ++++++++++-
 scripts/imgtool/image.py                      | 27 +++++++++++++------
 sim/mcuboot-sys/build.rs                      |  3 ++-
 13 files changed, 82 insertions(+), 42 deletions(-)
 rename boot/bootutil/src/{bootutil_image_hash.c => bootutil_img_hash.c} (95%)
 create mode 100644 docs/release-notes.d/multi-signature-support.md

diff --git a/boot/bootutil/CMakeLists.txt b/boot/bootutil/CMakeLists.txt
index f2944c54..11aa7b7e 100644
--- a/boot/bootutil/CMakeLists.txt
+++ b/boot/bootutil/CMakeLists.txt
@@ -18,7 +18,8 @@ target_sources(bootutil
     PRIVATE
         src/boot_record.c
         src/bootutil_find_key.c
-        src/bootutil_image_hash.c
+        src/bootutil_img_hash.c
+        src/bootutil_img_security_cnt.c
         src/bootutil_misc.c
         src/bootutil_public.c
         src/caps.c
@@ -36,22 +37,9 @@ target_sources(bootutil
         src/tlv.c
 )
 
-if(MCUBOOT_HW_ROLLBACK_PROT)
-    target_sources(bootutil
-        PRIVATE
-            src/bootutil_img_security_cnt.c
-    )
-endif()
-
 if(CONFIG_BOOT_RAM_LOAD)
     target_sources(bootutil
         PRIVATE
             src/ram_load.c
     )
 endif()
-
-target_compile_definitions(bootutil
-    PRIVATE
-        $<$<BOOL:${MCUBOOT_IMAGE_MULTI_SIG_SUPPORT}>:MCUBOOT_IMAGE_MULTI_SIG_SUPPORT>
-        $<$<BOOL:${MCUBOOT_IMAGE_MULTI_SIG_SUPPORT}>:MCUBOOT_ROTPK_MAX_KEYS_PER_IMAGE=${MCUBOOT_ROTPK_MAX_KEYS_PER_IMAGE}>
-)
diff --git a/boot/bootutil/include/bootutil/image.h b/boot/bootutil/include/bootutil/image.h
index bc8d871f..21fac5a3 100644
--- a/boot/bootutil/include/bootutil/image.h
+++ b/boot/bootutil/include/bootutil/image.h
@@ -254,12 +254,6 @@ int bootutil_img_hash(struct boot_loader_state *state,
 #endif
 );
 
-#ifdef MCUBOOT_IMAGE_MULTI_SIG_SUPPORT
-int boot_plat_check_key_policy(bool valid_sig, uint32_t key,
-                               bool *key_might_sign, bool *key_must_sign,
-                               uint8_t *key_must_sign_count);
-#endif /* MCUBOOT_IMAGE_MULTI_SIG_SUPPORT */
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/boot/bootutil/include/bootutil/sign_key.h b/boot/bootutil/include/bootutil/sign_key.h
index 613f6776..c1df9f54 100644
--- a/boot/bootutil/include/bootutil/sign_key.h
+++ b/boot/bootutil/include/bootutil/sign_key.h
@@ -28,6 +28,9 @@
 /* mcuboot_config.h is needed for MCUBOOT_HW_KEY to work */
 #include "mcuboot_config/mcuboot_config.h"
 
+#ifdef MCUBOOT_IMAGE_MULTI_SIG_SUPPORT
+#include <stdbool.h>
+#endif /* MCUBOOT_IMAGE_MULTI_SIG_SUPPORT */
 #ifdef MCUBOOT_BUILTIN_KEY
 #include "bootutil/fault_injection_hardening.h"
 #endif /* MCUBOOT_BUILTIN_KEY */
@@ -77,9 +80,29 @@ int boot_retrieve_public_key_hash(uint8_t image_index,
                                   uint8_t key_index,
                                   uint8_t *public_key_hash,
                                   size_t *key_hash_size);
-
 #endif /* !MCUBOOT_HW_KEY */
 
+#ifdef MCUBOOT_IMAGE_MULTI_SIG_SUPPORT
+/**
+ * @brief Checks the key policy for signature verification.
+ *
+ * Determines whether a given key might or must be used to sign an image,
+ * based on the validity of the signature and the key index. Updates the
+ * provided output parameters to reflect the policy.
+ *
+ * @param valid_sig            Indicates if the signature is valid.
+ * @param key                  The key index to check.
+ * @param[out] key_might_sign  Set to true if the key might be used to sign.
+ * @param[out] key_must_sign   Set to true if the key must be used to sign.
+ * @param[out] key_must_sign_count  Set to the number of keys that must sign.
+ *
+ * @return 0 on success, or a negative error code on failure.
+ */
+int boot_plat_check_key_policy(bool valid_sig, uint32_t key,
+                               bool *key_might_sign, bool *key_must_sign,
+                               uint8_t *key_must_sign_count);
+#endif /* MCUBOOT_IMAGE_MULTI_SIG_SUPPORT */
+
 extern const int bootutil_key_cnt;
 
 #ifdef __cplusplus
diff --git a/boot/bootutil/src/bootutil_find_key.c b/boot/bootutil/src/bootutil_find_key.c
index 58234bc4..36b0c189 100644
--- a/boot/bootutil/src/bootutil_find_key.c
+++ b/boot/bootutil/src/bootutil_find_key.c
@@ -27,7 +27,6 @@
  */
 
 #include <stdint.h>
-#include <flash_map_backend/flash_map_backend.h>
 
 #include "bootutil/bootutil_log.h"
 #include "bootutil/crypto/sha.h"
@@ -49,12 +48,10 @@ int bootutil_find_key(uint8_t image_index, uint8_t *key_id_buf, uint8_t key_id_b
     uint32_t key_id;
     FIH_DECLARE(fih_rc, FIH_FAILURE);
 
+    BOOT_LOG_DBG("bootutil_find_key: image_index %d", image_index);
     /* Key id is passed */
     assert(key_id_buf_len == sizeof(uint32_t));
-    key_id = (((uint32_t)key_id_buf[0] << 24) |
-                      ((uint32_t)key_id_buf[1] << 16)  |
-                      ((uint32_t)key_id_buf[2] << 8)   |
-                      ((uint32_t)key_id_buf[3]));
+    memcpy(&key_id, key_id_buf, sizeof(key_id));
 
     /* Check if key id is associated with the image */
     FIH_CALL(boot_verify_key_id_for_image, fih_rc, image_index, key_id);
@@ -82,6 +79,7 @@ int bootutil_find_key(uint8_t image_index, uint8_t *key, uint16_t key_len)
     bootutil_sha_finish(&sha_ctx, hash);
     bootutil_sha_drop(&sha_ctx);
 
+    BOOT_LOG_DBG("bootutil_find_key: image_index %d", image_index);
     for(key_index = 0; key_index < NUM_OF_KEYS; key_index++) {
         rc = boot_retrieve_public_key_hash(image_index, key_index, key_hash, &key_hash_size);
         if (rc) {
@@ -116,6 +114,7 @@ int bootutil_find_key(uint8_t image_index, uint8_t *keyhash, uint8_t keyhash_len
     const struct bootutil_key *key;
     (void)image_index;
 
+    BOOT_LOG_DBG("bootutil_find_key");
     if (keyhash_len > IMAGE_HASH_SIZE) {
         return -1;
     }
diff --git a/boot/bootutil/src/bootutil_image_hash.c b/boot/bootutil/src/bootutil_img_hash.c
similarity index 95%
rename from boot/bootutil/src/bootutil_image_hash.c
rename to boot/bootutil/src/bootutil_img_hash.c
index 14aa830f..17946a97 100644
--- a/boot/bootutil/src/bootutil_image_hash.c
+++ b/boot/bootutil/src/bootutil_img_hash.c
@@ -29,13 +29,12 @@
 #include <stdint.h>
 #include <flash_map_backend/flash_map_backend.h>
 
-#include "bootutil/bootutil_log.h"
 #include "bootutil/crypto/sha.h"
 #include "bootutil/fault_injection_hardening.h"
 #include "bootutil/image.h"
-#include "bootutil/sign_key.h"
 #include "bootutil_priv.h"
 #include "mcuboot_config/mcuboot_config.h"
+#include "bootutil/bootutil_log.h"
 
 #ifndef MCUBOOT_SIGN_PURE
 /*
@@ -87,6 +86,7 @@ bootutil_img_hash(struct boot_loader_state *state,
 #endif
 #endif
 
+    BOOT_LOG_DBG("bootutil_img_hash");
 #ifdef MCUBOOT_ENC_IMAGES
     if (state == NULL) {
         enc_state = NULL;
@@ -99,6 +99,7 @@ bootutil_img_hash(struct boot_loader_state *state,
     /* Encrypted images only exist in the secondary slot */
     if (MUST_DECRYPT(fap, image_index, hdr) &&
             !boot_enc_valid(enc_state, 1)) {
+        BOOT_LOG_DBG("bootutil_img_hash: error encrypted image found in primary slot");
         return -1;
     }
 #endif
@@ -166,6 +167,8 @@ bootutil_img_hash(struct boot_loader_state *state,
 #endif
         if (rc) {
             bootutil_sha_drop(&sha_ctx);
+            BOOT_LOG_DBG("bootutil_img_validate Error %d reading data chunk %p %u %u",
+                         rc, fap, off, blk_sz);
             return rc;
         }
 #ifdef MCUBOOT_ENC_IMAGES
diff --git a/boot/bootutil/src/image_ed25519.c b/boot/bootutil/src/image_ed25519.c
index ffb8cec3..95b976a7 100644
--- a/boot/bootutil/src/image_ed25519.c
+++ b/boot/bootutil/src/image_ed25519.c
@@ -163,7 +163,7 @@ out:
 fih_ret
 bootutil_verify_img(uint8_t *img, uint32_t size,
                     uint8_t *sig, size_t slen,
-                    uint8_t key_id)
+                    uint32_t key_id)
 {
     FIH_DECLARE(fih_rc, FIH_FAILURE);
 
diff --git a/boot/bootutil/src/image_validate.c b/boot/bootutil/src/image_validate.c
index b1890fcc..cde3f28b 100644
--- a/boot/bootutil/src/image_validate.c
+++ b/boot/bootutil/src/image_validate.c
@@ -466,9 +466,8 @@ bootutil_img_validate(struct boot_loader_state *state,
 #ifdef EXPECTED_SIG_TLV
 #ifdef MCUBOOT_IMAGE_MULTI_SIG_SUPPORT
     if (FIH_NOT_EQ(key_must_sign, true) || FIH_NOT_EQ(key_might_sign, true)) {
-        FIH_RET(FIH_FAILURE);
-    } else {
-        FIH_RET(FIH_SUCCESS);
+        rc = -1;
+        goto out;
     }
 #else
     FIH_SET(fih_rc, valid_signature);
diff --git a/boot/espressif/CMakeLists.txt b/boot/espressif/CMakeLists.txt
index 05358839..0fa2759e 100644
--- a/boot/espressif/CMakeLists.txt
+++ b/boot/espressif/CMakeLists.txt
@@ -236,6 +236,9 @@ endif()
 
 set(bootutil_srcs
     ${BOOTUTIL_DIR}/src/boot_record.c
+    ${BOOTUTIL_DIR}/src/bootutil_find_key.c
+    ${BOOTUTIL_DIR}/src/bootutil_img_hash.c
+    ${BOOTUTIL_DIR}/src/bootutil_img_security_cnt.c
     ${BOOTUTIL_DIR}/src/bootutil_misc.c
     ${BOOTUTIL_DIR}/src/bootutil_public.c
     ${BOOTUTIL_DIR}/src/caps.c
diff --git a/boot/zephyr/CMakeLists.txt b/boot/zephyr/CMakeLists.txt
index 15996254..27a10221 100644
--- a/boot/zephyr/CMakeLists.txt
+++ b/boot/zephyr/CMakeLists.txt
@@ -105,6 +105,9 @@ endif()
 # Generic bootutil sources and includes.
 zephyr_library_include_directories(${BOOT_DIR}/bootutil/include)
 zephyr_library_sources(
+  ${BOOT_DIR}/bootutil/src/bootutil_find_key.c
+  ${BOOT_DIR}/bootutil/src/bootutil_img_hash.c
+  ${BOOT_DIR}/bootutil/src/bootutil_img_security_cnt.c
   ${BOOT_DIR}/bootutil/src/image_validate.c
   ${BOOT_DIR}/bootutil/src/tlv.c
   ${BOOT_DIR}/bootutil/src/encrypted.c
diff --git a/docs/release-notes.d/multi-signature-support.md b/docs/release-notes.d/multi-signature-support.md
new file mode 100644
index 00000000..8cfc19f1
--- /dev/null
+++ b/docs/release-notes.d/multi-signature-support.md
@@ -0,0 +1,2 @@
+- imgtool: added support for multi-signature image generation, enabling firmware images to be signed with multiple keys (e.g. for multi-party signing).
+- bootutil: added support for verifying multi-signature TLV entries, allowing the bootloader to validate all signatures on an image during startup.
diff --git a/samples/mcuboot_config/mcuboot_config.template.h b/samples/mcuboot_config/mcuboot_config.template.h
index ce613bd8..27b3aecc 100644
--- a/samples/mcuboot_config/mcuboot_config.template.h
+++ b/samples/mcuboot_config/mcuboot_config.template.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2018 Open Source Foundries Limited
- * Copyright (c) 2019-2024 Arm Limited
+ * Copyright (c) 2019-2025 Arm Limited
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -33,6 +33,20 @@
 /* Uncomment for ECDSA signatures using curve P-256. */
 /* #define MCUBOOT_SIGN_EC256 */
 
+/*
+ * Multi-signature support
+ *
+ * Currently, only ECDSA signatures using curve P-256 and P-384
+ * are supported for multi-signature images.
+ */
+
+/* Uncomment to enable verification of images with multiple signatures */
+/* #define MCUBOOT_IMAGE_MULTI_SIG_SUPPORT */
+#ifdef MCUBOOT_IMAGE_MULTI_SIG_SUPPORT
+/*â€” How many RoTPK keys per image â€”*/
+#define MCUBOOT_ROTPK_MAX_KEYS_PER_IMAGE 2
+#endif
+
 /*
  * Public key handling
  *
diff --git a/scripts/imgtool/image.py b/scripts/imgtool/image.py
index 69200392..f313743a 100644
--- a/scripts/imgtool/image.py
+++ b/scripts/imgtool/image.py
@@ -664,8 +664,8 @@ class Image:
             for i, key in enumerate(keys):
                 # If key IDs are provided, and we have enough for this key, add it first.
                 if self.psa_key_ids is not None and len(self.psa_key_ids) > i:
-                    # Convert key id (an integer) to 4-byte big-endian bytes.
-                    kid_bytes = self.psa_key_ids[i].to_bytes(4, 'big')
+                    # Convert key id (an integer) to 4-byte defined endian bytes.
+                    kid_bytes = self.psa_key_ids[i].to_bytes(4, self.endian)
                     tlv.add('KEYID', kid_bytes)  # Using the TLV tag that corresponds to key IDs.
 
                 if public_key_format == 'hash':
@@ -850,7 +850,12 @@ class Image:
         # Locate the first TLV info header
         tlv_off = header_size + img_size
         tlv_info = b[tlv_off:tlv_off + TLV_INFO_SIZE]
-        magic, tlv_tot = struct.unpack('HH', tlv_info)
+        if len(tlv_info) < TLV_INFO_SIZE:
+            # no protected block present, jump straight to unprotected
+            magic = TLV_INFO_MAGIC
+            tlv_tot = len(b) - tlv_off
+        else:
+            magic, tlv_tot = struct.unpack('HH', tlv_info)
 
         # If it's the protected-TLV block, skip it
         if magic == TLV_PROT_INFO_MAGIC:
@@ -873,8 +878,12 @@ class Image:
         is_pure = False
         scan_off = unprot_off
         while scan_off < unprot_end:
-            tlv = b[scan_off:scan_off + TLV_SIZE]
-            tlv_type, _, tlv_len = struct.unpack('BBH', tlv)
+            # if fewer than TLV_SIZE bytes remain, break
+            if scan_off + TLV_SIZE > len(b):
+                break
+            tlv_hdr = b[scan_off:scan_off + TLV_SIZE]
+            tlv_type, _, tlv_len = struct.unpack('BBH', tlv_hdr)
+
             if tlv_type == TLV_VALUES['SIG_PURE']:
                 is_pure = True
                 break
@@ -890,8 +899,11 @@ class Image:
 
         # Verify hash and signatures
         while scan_off < unprot_end:
-            tlv = b[scan_off:scan_off + TLV_SIZE]
-            tlv_type, _, tlv_len = struct.unpack('BBH', tlv)
+            # stop if not enough bytes for another TLV header
+            if scan_off + TLV_SIZE > len(b):
+                break
+            tlv_hdr = b[scan_off:scan_off + TLV_SIZE]
+            tlv_type, _, tlv_len = struct.unpack('BBH', tlv_hdr)
             if is_sha_tlv(tlv_type):
                 if not tlv_matches_key_type(tlv_type, key[0]):
                     return VerifyResult.KEY_MISMATCH, None, None, None
@@ -940,7 +952,6 @@ class Image:
         else:
             return VerifyResult.INVALID_SIGNATURE, None, None, None
 
-
     def set_key_ids(self, psa_key_ids):
         """Set list of key IDs (integers) to be inserted before each signature."""
         self.psa_key_ids = psa_key_ids
diff --git a/sim/mcuboot-sys/build.rs b/sim/mcuboot-sys/build.rs
index 20f36216..95cb3d3c 100644
--- a/sim/mcuboot-sys/build.rs
+++ b/sim/mcuboot-sys/build.rs
@@ -449,7 +449,8 @@ fn main() {
     }
 
     conf.file("../../boot/bootutil/src/bootutil_find_key.c");
-    conf.file("../../boot/bootutil/src/bootutil_image_hash.c");
+    conf.file("../../boot/bootutil/src/bootutil_img_hash.c");
+    conf.file("../../boot/bootutil/src/bootutil_img_security_cnt.c");
     conf.file("../../boot/bootutil/src/image_validate.c");
     if sig_rsa || sig_rsa3072 {
         conf.file("../../boot/bootutil/src/image_rsa.c");
-- 
2.34.1

