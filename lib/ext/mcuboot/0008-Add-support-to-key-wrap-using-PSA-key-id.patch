From 40a570cc97622b15ee43e9031c53f7b7270a809a Mon Sep 17 00:00:00 2001
From: Waleed Elmelegy <waleed.elmelegy@arm.com>
Date: Thu, 14 Aug 2025 15:17:45 +0000
Subject: [PATCH] Add support to key wrap using PSA key id

Signed-off-by: Waleed Elmelegy <waleed.elmelegy@arm.com>
Change-Id: I0c6e8df66a89e61cd3ba9da9e356edd6e857e32c
---
 .../bootutil/include/bootutil/crypto/aes_kw.h | 59 +++----------------
 boot/bootutil/include/bootutil/enc_key.h      |  9 ++-
 boot/bootutil/src/bootutil_misc.c             |  4 +-
 boot/bootutil/src/bootutil_priv.h             |  2 +-
 boot/bootutil/src/encrypted.c                 | 49 +++++++++++++--
 boot/bootutil/src/encrypted_psa.c             |  2 +-
 boot/bootutil/src/loader.c                    |  2 +-
 enc-aeskw-128.b64                             |  1 +
 enc-aeskw-128_ns.b64                          |  1 +
 9 files changed, 67 insertions(+), 62 deletions(-)
 create mode 100644 enc-aeskw-128.b64
 create mode 100644 enc-aeskw-128_ns.b64

diff --git a/boot/bootutil/include/bootutil/crypto/aes_kw.h b/boot/bootutil/include/bootutil/crypto/aes_kw.h
index 4cd7a860..1f9dbefe 100644
--- a/boot/bootutil/include/bootutil/crypto/aes_kw.h
+++ b/boot/bootutil/include/bootutil/crypto/aes_kw.h
@@ -51,63 +51,25 @@ extern "C" {
 typedef struct {
     psa_cipher_operation_t op;
     psa_key_id_t key_id;
-    uint8_t key[BOOTUTIL_CRYPTO_AES_KW_KEY_SIZE];
     psa_key_attributes_t key_attributes;
 } bootutil_aes_kw_context;
 
-static int import_key_for_kw(bootutil_aes_kw_context *ctx)
-{
-    psa_status_t status = PSA_ERROR_INVALID_ARGUMENT;
-    psa_key_usage_t usage = (PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
-    size_t key_len;
-
-    key_len = PSA_BITS_TO_BYTES(psa_get_key_bits(&ctx->key_attributes));
-    if (key_len == 0) {
-        /* Key has not been set using bootutil_aes_kw_set_unwrap_key(). */
-        return PSA_ERROR_INVALID_ARGUMENT;
-    }
-
-    /* Setup the key policy */
-    psa_set_key_usage_flags(&ctx->key_attributes, usage);
-    psa_set_key_algorithm(&ctx->key_attributes, PSA_ALG_ECB_NO_PADDING);
-    psa_set_key_type(&ctx->key_attributes, PSA_KEY_TYPE_AES);
-    psa_set_key_lifetime(&ctx->key_attributes, PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(
-        PSA_KEY_PERSISTENCE_DEFAULT, PSA_KEY_LOCATION_LOCAL_STORAGE));
-
-    /* Import a key */
-    status = psa_import_key(&ctx->key_attributes, ctx->key, key_len, &(ctx->key_id));
-    return (int)status;
-}
-
-
 static inline void bootutil_aes_kw_init(bootutil_aes_kw_context *ctx)
 {
     ctx->op = psa_cipher_operation_init();
     ctx->key_id = PSA_KEY_ID_NULL;
     ctx->key_attributes = psa_key_attributes_init();
-    memset(ctx->key, 0, sizeof(ctx->key));
     return;
 }
 
 static inline void bootutil_aes_kw_drop(bootutil_aes_kw_context *ctx)
 {
-    memset(ctx->key, 0, sizeof(ctx->key));
-    psa_set_key_bits(&ctx->key_attributes, 0);
-
-    if (ctx->key_id != PSA_KEY_ID_NULL) {
-        (void)psa_destroy_key(ctx->key_id);
-        ctx->key_id = PSA_KEY_ID_NULL;
-    }
+    memset(ctx, 0, sizeof(bootutil_aes_kw_context));
 }
 
-static inline int bootutil_aes_kw_set_unwrap_key(bootutil_aes_kw_context *ctx, const uint8_t *k, uint32_t klen)
+static inline int bootutil_aes_kw_set_unwrap_key(bootutil_aes_kw_context *ctx, psa_key_id_t key_id)
 {
-    if (klen != 16 && klen != 24 && klen != 32) {
-        return PSA_ERROR_INVALID_ARGUMENT;
-    }
-
-    psa_set_key_bits(&ctx->key_attributes, PSA_BYTES_TO_BITS(klen));
-    memcpy(ctx->key, k, klen);
+    ctx->key_id = key_id;
     return 0;
 }
 
@@ -116,13 +78,13 @@ static inline int bootutil_aes_kw_unwrap(bootutil_aes_kw_context *ctx, const uin
     psa_status_t status = PSA_ERROR_INVALID_ARGUMENT;
     psa_key_id_t output_key_id = PSA_KEY_ID_NULL;
     size_t output_key_len = 0;
+    psa_key_attributes_t key_attributes;
 
-    status = import_key_for_kw(ctx);
-    if (status != PSA_SUCCESS) {
-        return status;
-    }
+    psa_set_key_algorithm(&key_attributes, PSA_ALG_CTR);
+    psa_set_key_type(&key_attributes, PSA_KEY_TYPE_AES);
+    psa_set_key_usage_flags(&key_attributes, (PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT));
 
-    status = psa_unwrap_key(&ctx->key_attributes, ctx->key_id, PSA_ALG_ECB_NO_PADDING,
+    status = psa_unwrap_key(&key_attributes, ctx->key_id, PSA_ALG_ECB_NO_PADDING,
                              wrapped_key, wrapped_key_len, &output_key_id);
     if (status != PSA_SUCCESS) {
         return status;
@@ -133,11 +95,6 @@ static inline int bootutil_aes_kw_unwrap(bootutil_aes_kw_context *ctx, const uin
         return status;
     }
 
-    /* TFM bl2 PSA keystore implementation  has only 1 slot so we reimport
-       the key because otherwise destroying it later would fail when mcuboot
-       calls bootutil_aes_kw_drop(). */
-    status = import_key_for_kw(ctx);
-
     return status;
 }
 
diff --git a/boot/bootutil/include/bootutil/enc_key.h b/boot/bootutil/include/bootutil/enc_key.h
index 9240d699..887de988 100644
--- a/boot/bootutil/include/bootutil/enc_key.h
+++ b/boot/bootutil/include/bootutil/enc_key.h
@@ -53,15 +53,22 @@ struct enc_key_data {
  *                           its length.
  *
  * @return                   0 on success; nonzero on failure.
+ *                           In case of using PSA Crypto key ID to private key.
  *
  */
+#if defined(MCUBOOT_ENCRYPT_KW) && (defined(MCUBOOT_USE_PSA_CRYPTO) || defined(MCUBOOT_USE_MBED_TLS))
+uint32_t boot_enc_retrieve_private_key(uint32_t image_id);
+#else
 int boot_enc_retrieve_private_key(struct bootutil_key **private_key);
+#endif
 
 struct boot_status;
 struct boot_loader_state;
 
 /* Decrypt random, symmetric encryption key */
-int boot_decrypt_key(const uint8_t *buf, uint8_t *enckey);
+int boot_decrypt_key(const uint8_t *buf, uint8_t *enckey, uint32_t image_id);
+
+uint32_t get_enc_key_id_for_image(uint32_t image_id);
 
 int boot_enc_init(struct enc_key_data *enc_state, uint8_t slot);
 int boot_enc_drop(struct enc_key_data *enc_state, uint8_t slot);
diff --git a/boot/bootutil/src/bootutil_misc.c b/boot/bootutil/src/bootutil_misc.c
index 0091165d..e4e7fe36 100644
--- a/boot/bootutil/src/bootutil_misc.c
+++ b/boot/bootutil/src/bootutil_misc.c
@@ -345,7 +345,7 @@ boot_read_swap_size(const struct flash_area *fap, uint32_t *swap_size)
 
 #ifdef MCUBOOT_ENC_IMAGES
 int
-boot_read_enc_key(const struct flash_area *fap, uint8_t slot, struct boot_status *bs)
+boot_read_enc_key(const struct flash_area *fap, uint8_t slot, struct boot_status *bs, uint32_t image_id)
 {
     uint32_t off;
 #if MCUBOOT_SWAP_SAVE_ENCTLV
@@ -364,7 +364,7 @@ boot_read_enc_key(const struct flash_area *fap, uint8_t slot, struct boot_status
         }
         /* Only try to decrypt non-erased TLV metadata */
         if (i != BOOT_ENC_TLV_ALIGN_SIZE) {
-            rc = boot_decrypt_key(bs->enctlv[slot], bs->enckey[slot]);
+            rc = boot_decrypt_key(bs->enctlv[slot], bs->enckey[slot], image_id);
         }
     }
 #else
diff --git a/boot/bootutil/src/bootutil_priv.h b/boot/bootutil/src/bootutil_priv.h
index c08c4abb..f62a8562 100644
--- a/boot/bootutil/src/bootutil_priv.h
+++ b/boot/bootutil/src/bootutil_priv.h
@@ -360,7 +360,7 @@ bool boot_status_is_reset(const struct boot_status *bs);
 int boot_write_enc_key(const struct flash_area *fap, uint8_t slot,
                        const struct boot_status *bs);
 int boot_read_enc_key(const struct flash_area *fap, uint8_t slot,
-                      struct boot_status *bs);
+                      struct boot_status *bs, uint32_t image_id);
 #endif
 
 #ifdef MCUBOOT_SWAP_USING_SCRATCH
diff --git a/boot/bootutil/src/encrypted.c b/boot/bootutil/src/encrypted.c
index bbe40751..1c9d9a6e 100644
--- a/boot/bootutil/src/encrypted.c
+++ b/boot/bootutil/src/encrypted.c
@@ -93,6 +93,29 @@ static int bootutil_constant_time_compare(const uint8_t *a, const uint8_t *b, si
 #endif
 
 #if defined(MCUBOOT_ENCRYPT_KW)
+#if defined(MCUBOOT_USE_PSA_CRYPTO) || defined(MCUBOOT_USE_MBED_TLS)
+static int
+key_unwrap(const uint8_t *wrapped, uint8_t *enckey, psa_key_id_t key_id)
+{
+    bootutil_aes_kw_context aes_kw;
+    int rc;
+
+    bootutil_aes_kw_init(&aes_kw);
+    rc = bootutil_aes_kw_set_unwrap_key(&aes_kw, key_id);
+    if (rc != 0) {
+        goto done;
+    }
+
+    rc = bootutil_aes_kw_unwrap(&aes_kw, wrapped, BOOT_ENC_TLV_SIZE, enckey, BOOT_ENC_KEY_SIZE);
+    if (rc != 0) {
+        goto done;
+    }
+
+done:
+    bootutil_aes_kw_drop(&aes_kw);
+    return rc;
+}
+#else
 static int
 key_unwrap(const uint8_t *wrapped, uint8_t *enckey, struct bootutil_key *bootutil_enc_key)
 {
@@ -113,6 +136,7 @@ done:
     bootutil_aes_kw_drop(&aes_kw);
     return rc;
 }
+#endif /* MCUBOOT_USE_PSA_CRYPTO || MCUBOOT_USE_MBED_TLS */
 #endif /* MCUBOOT_ENCRYPT_KW */
 
 #if defined(MCUBOOT_ENCRYPT_EC256)
@@ -370,12 +394,19 @@ extern const struct bootutil_key bootutil_enc_key;
  * Default implementation to retrieve the private encryption key which is
  * embedded in the bootloader code (when MCUBOOT_ENC_BUILTIN_KEY is not defined).
  */
+#if defined(MCUBOOT_ENCRYPT_KW) && (defined(MCUBOOT_USE_PSA_CRYPTO) || defined(MCUBOOT_USE_MBED_TLS))
+uint32_t boot_enc_retrieve_private_key(uint32_t image_id)
+{
+    return get_enc_key_id_for_image(image_id);
+}
+#else
 int boot_enc_retrieve_private_key(struct bootutil_key **private_key)
 {
     *private_key = (struct bootutil_key *)&bootutil_enc_key;
 
     return 0;
 }
+#endif /* MCUBOOT_USE_PSA_CRYPTO || MCUBOOT_USE_MBED_TLS */
 #endif /* !MCUBOOT_ENC_BUILTIN_KEY */
 
 #if ( (defined(MCUBOOT_ENCRYPT_RSA) && defined(MCUBOOT_USE_MBED_TLS) && !defined(MCUBOOT_USE_PSA_CRYPTO)) || \
@@ -403,7 +434,7 @@ static int fake_rng(void *p_rng, unsigned char *output, size_t len)
  * @param enckey An AES-128 or AES-256 key sized buffer to store to plain key.
  */
 int
-boot_decrypt_key(const uint8_t *buf, uint8_t *enckey)
+boot_decrypt_key(const uint8_t *buf, uint8_t *enckey, uint32_t image_id)
 {
 #if defined(MCUBOOT_ENCRYPT_RSA)
     bootutil_rsa_context rsa;
@@ -429,8 +460,13 @@ boot_decrypt_key(const uint8_t *buf, uint8_t *enckey)
     uint8_t counter[BOOT_ENC_BLOCK_SIZE];
     uint16_t len;
 #endif
-    struct bootutil_key *bootutil_enc_key = NULL;
     int rc = -1;
+#if defined(MCUBOOT_ENCRYPT_KW) && (defined(MCUBOOT_USE_PSA_CRYPTO) || defined(MCUBOOT_USE_MBED_TLS))
+    int key_id;
+
+    key_id = boot_enc_retrieve_private_key(image_id);
+#else
+    struct bootutil_key *bootutil_enc_key = NULL;
 
     rc = boot_enc_retrieve_private_key(&bootutil_enc_key);
     if (rc) {
@@ -440,6 +476,7 @@ boot_decrypt_key(const uint8_t *buf, uint8_t *enckey)
     if (bootutil_enc_key == NULL) {
         return rc;
     }
+#endif /* MCUBOOT_ENCRYPT_KW && (MCUBOOT_USE_PSA_CRYPTO || MCUBOOT_USE_MBED_TLS) */
 
 #if defined(MCUBOOT_ENCRYPT_RSA)
 
@@ -463,10 +500,12 @@ boot_decrypt_key(const uint8_t *buf, uint8_t *enckey)
 #endif /* defined(MCUBOOT_ENCRYPT_RSA) */
 
 #if defined(MCUBOOT_ENCRYPT_KW)
-
+#if defined(MCUBOOT_USE_PSA_CRYPTO) || defined(MCUBOOT_USE_MBED_TLS)
+    rc = key_unwrap(buf, enckey, key_id);
+#else
     assert(*bootutil_enc_key->len == BOOT_ENC_KEY_SIZE);
     rc = key_unwrap(buf, enckey, bootutil_enc_key);
-
+#endif /* MCUBOOT_USE_PSA_CRYPTO || MCUBOOT_USE_MBED_TLS */
 #endif /* defined(MCUBOOT_ENCRYPT_KW) */
 
 #if defined(MCUBOOT_ENCRYPT_EC256)
@@ -665,7 +704,7 @@ boot_enc_load(struct boot_loader_state *state, int slot,
         return -1;
     }
 
-    return boot_decrypt_key(buf, bs->enckey[slot]);
+    return boot_decrypt_key(buf, bs->enckey[slot], state->curr_img_idx);
 }
 
 int
diff --git a/boot/bootutil/src/encrypted_psa.c b/boot/bootutil/src/encrypted_psa.c
index 313372fb..bd786cf0 100644
--- a/boot/bootutil/src/encrypted_psa.c
+++ b/boot/bootutil/src/encrypted_psa.c
@@ -122,7 +122,7 @@ extern const struct bootutil_key bootutil_enc_key;
  * @param enckey An AES-128 or AES-256 key sized buffer to store to plain key.
  */
 int
-boot_decrypt_key(const uint8_t *buf, uint8_t *enckey)
+boot_decrypt_key(const uint8_t *buf, uint8_t *enckey, uint32_t image_id)
 {
     uint8_t derived_key[HKDF_SIZE];
     uint8_t *cp;
diff --git a/boot/bootutil/src/loader.c b/boot/bootutil/src/loader.c
index ffd2456a..75b7ad2b 100644
--- a/boot/bootutil/src/loader.c
+++ b/boot/bootutil/src/loader.c
@@ -1820,7 +1820,7 @@ boot_swap_image(struct boot_loader_state *state, struct boot_status *bs)
 
 #ifdef MCUBOOT_ENC_IMAGES
         for (slot = 0; slot < BOOT_NUM_SLOTS; slot++) {
-            rc = boot_read_enc_key(fap, slot, bs);
+            rc = boot_read_enc_key(fap, slot, bs, state->curr_img_idx);
             assert(rc == 0);
 
             for (i = 0; i < BOOT_ENC_KEY_SIZE; i++) {
diff --git a/enc-aeskw-128.b64 b/enc-aeskw-128.b64
new file mode 100644
index 00000000..50848858
--- /dev/null
+++ b/enc-aeskw-128.b64
@@ -0,0 +1 @@
+AES-KW:V6U9usCfWZMcM2R+wXIDC6oUIVABjn1FLEpeyxqNY7c=
diff --git a/enc-aeskw-128_ns.b64 b/enc-aeskw-128_ns.b64
new file mode 100644
index 00000000..19a1ae0e
--- /dev/null
+++ b/enc-aeskw-128_ns.b64
@@ -0,0 +1 @@
+AES-KW:0A0MAOzX+eye0ccxYGi1wL/LAxg/+vbFrHElpGZqHi8=
-- 
2.43.0

